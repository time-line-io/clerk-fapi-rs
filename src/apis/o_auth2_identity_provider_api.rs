/*
 * Clerk Frontend API
 *
 * The Clerk REST Frontend API, meant to be accessed from a browser or native environment.  This is a Form Based API and all the data must be sent and formatted according to the `application/x-www-form-urlencoded` content type.  ### Versions  When the API changes in a way that isn't compatible with older versions, a new version is released. Each version is identified by its release date, e.g. `2021-02-05`. For more information, please see [Clerk API Versions](https://clerk.com/docs/backend-requests/versioning/overview).  ### Using the Try It Console  The `Try It` feature of the docs only works for **Development Instances** when using the `DevBrowser` security scheme. To use it, first generate a dev instance token from the `/v1/dev_browser` endpoint.  Please see https://clerk.com/docs for more information.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@clerk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_o_auth_consent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthConsentError {
    Status400(models::ClerkErrors),
    Status401(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status404(models::ClerkErrors),
    Status422(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthTokenError {
    Status400(models::GetOAuthToken400Response),
    Status401(models::GetOAuthToken401Response),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth_token_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthTokenInfoError {
    Status401(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth_user_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthUserInfoError {
    Status400(models::ClerkErrors),
    Status401(models::ClerkErrors),
    Status403(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth_user_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthUserInfoPostError {
    Status400(models::ClerkErrors),
    Status401(models::ClerkErrors),
    Status403(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_o_auth_client`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterOAuthClientError {
    Status400(models::OAuthDynamicClientRegistrationError),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_o_auth_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestOAuthAuthorizeError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_o_auth_authorize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestOAuthAuthorizePostError {
    Status400(),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_o_auth_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeOAuthTokenError {
    Status400(models::GetOAuthToken400Response),
    Status401(models::GetOAuthToken401Response),
    UnknownValue(serde_json::Value),
}


/// Get required consent information for a given OAuth Application Client ID
pub async fn get_o_auth_consent(configuration: &configuration::Configuration, client_id: &str, _clerk_session_id: Option<&str>) -> Result<models::OAuthConsentInfo, Error<GetOAuthConsentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_query__clerk_session_id = _clerk_session_id;

    let uri_str = format!("{}/v1/me/oauth/consent/{client_id}", configuration.base_path, client_id=crate::apis::urlencode(p_path_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query__clerk_session_id {
        req_builder = req_builder.query(&[("_clerk_session_id", &param_value.to_string())]);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthConsentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthConsentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuthConsentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange an authorization grant for OAuth2 tokens (access token, refresh token, and optionally ID token).  This endpoint implements the OAuth 2.0 Token Endpoint (RFC 6749) and OpenID Connect token endpoint. It supports two grant types: `authorization_code` and `refresh_token`.  #### Grant Types  - **`authorization_code`**: Exchange an authorization code for tokens - **`refresh_token`**: Refresh an access token using a refresh token  #### Authentication  - **Confidential clients**: Must authenticate using one of the following methods:   - HTTP Basic Authentication: `Authorization: Basic base64(client_id:client_secret)`   - Client credentials in request body: Include `client_id` and `client_secret` in form fields   - *Note: Both methods (`client_secret_basic` and `client_secret_post`) are treated equivalently* - **Public clients** (PKCE flow): No client secret required. Must provide `client_id` and `code_verifier` in request body.  #### PKCE (Proof Key for Code Exchange)  Public clients and clients that cannot securely store a client secret must use PKCE (RFC 7636). When using PKCE: - Include `code_challenge` and `code_challenge_method` in the authorization request - Include `code_verifier` in the token request (instead of `client_secret`)  #### Scopes  Available scopes: - `openid` - Enables OpenID Connect features, returns an `id_token` in the response - `email` - User's email address - `profile` - Basic profile information (name, username, picture, etc.) - `public_metadata` - Clerk custom scope for public metadata - `private_metadata` - Clerk custom scope for private metadata  Default scopes (if not specified): `email profile`  #### Token Lifespans  - **Access token**: 1 day (86400 seconds) - **Refresh token**: 10 years - **ID token**: 1 day (86400 seconds) - **Authorization code**: 10 minutes (must be exchanged within this time)  #### OpenID Connect  When the `openid` scope is included in the authorization request, the token response will include an `id_token` field containing a signed JWT with user identity information per the OpenID Connect specification. The `id_token` will be refreshed along with the access token when using the `refresh_token` grant type.
pub async fn get_o_auth_token(configuration: &configuration::Configuration, grant_type: &str, code: Option<&str>, redirect_uri: Option<&str>, code_verifier: Option<&str>, client_id: Option<&str>, client_secret: Option<&str>, refresh_token: Option<&str>, scope: Option<&str>) -> Result<models::OAuthToken, Error<GetOAuthTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_code = code;
    let p_form_redirect_uri = redirect_uri;
    let p_form_code_verifier = code_verifier;
    let p_form_client_id = client_id;
    let p_form_client_secret = client_secret;
    let p_form_refresh_token = refresh_token;
    let p_form_scope = scope;

    let uri_str = format!("{}/oauth/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_form_grant_type.to_string());
    if let Some(param_value) = p_form_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    if let Some(param_value) = p_form_redirect_uri {
        multipart_form_params.insert("redirect_uri", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_verifier {
        multipart_form_params.insert("code_verifier", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_id {
        multipart_form_params.insert("client_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_secret {
        multipart_form_params.insert("client_secret", param_value.to_string());
    }
    if let Some(param_value) = p_form_refresh_token {
        multipart_form_params.insert("refresh_token", param_value.to_string());
    }
    if let Some(param_value) = p_form_scope {
        multipart_form_params.insert("scope", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuthTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information for an access or refresh token
pub async fn get_o_auth_token_info(configuration: &configuration::Configuration, token: &str, token_type_hint: Option<&str>, scope: Option<&str>) -> Result<models::OAuthTokenInfo, Error<GetOAuthTokenInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_token = token;
    let p_form_token_type_hint = token_type_hint;
    let p_form_scope = scope;

    let uri_str = format!("{}/oauth/token_info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("token", p_form_token.to_string());
    if let Some(param_value) = p_form_token_type_hint {
        multipart_form_params.insert("token_type_hint", param_value.to_string());
    }
    if let Some(param_value) = p_form_scope {
        multipart_form_params.insert("scope", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthTokenInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthTokenInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuthTokenInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user info in exchange for a valid OAuth2 access token.
pub async fn get_o_auth_user_info(configuration: &configuration::Configuration, ) -> Result<models::OAuthUserInfo, Error<GetOAuthUserInfoError>> {

    let uri_str = format!("{}/oauth/userinfo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthUserInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthUserInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuthUserInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user info in exchange for a valid OAuth2 access token.
pub async fn get_o_auth_user_info_post(configuration: &configuration::Configuration, ) -> Result<models::OAuthUserInfo, Error<GetOAuthUserInfoPostError>> {

    let uri_str = format!("{}/oauth/userinfo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthUserInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthUserInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuthUserInfoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Registers a new OAuth 2.0 client with the authorization server according to RFC 7591 (OAuth 2.0 Dynamic Client Registration Protocol).  This endpoint allows clients to dynamically register by submitting client metadata. Upon successful registration, the authorization server assigns a unique client identifier and optionally a client secret (for confidential clients).  **Authentication:** This endpoint does not require authentication as it is used for initial client registration. However, the endpoint is disabled by default and must be enabled in the Instance settings.  **Client Types:** - **Confidential clients** receive both a `client_id` and `client_secret` - **Public clients** (using `token_endpoint_auth_method: none`) receive only a `client_id`  **Key Points:** - All dynamically registered clients must use the consent screen (cannot be disabled) - PKCE is not required for dynamically registered clients - The `redirect_uris` field is required and must contain at least one valid redirect URI - If `client_name` is not provided, the `client_id` will be used as the display name - If `scope` is not provided, default scopes will be assigned - The `token_endpoint_auth_method` values `client_secret_basic` and `client_secret_post` are   treated equivalently in the current implementation; both methods can be used at the   token endpoint  See [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591) for complete specification details.
pub async fn register_o_auth_client(configuration: &configuration::Configuration, o_auth_dynamic_client_registration_request: models::OAuthDynamicClientRegistrationRequest) -> Result<models::OAuthDynamicClientRegistrationResponse, Error<RegisterOAuthClientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_o_auth_dynamic_client_registration_request = o_auth_dynamic_client_registration_request;

    let uri_str = format!("{}/oauth/register", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_o_auth_dynamic_client_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthDynamicClientRegistrationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthDynamicClientRegistrationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterOAuthClientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request OAuth2 authorization. If successful, receive authorization grant via redirect.
pub async fn request_o_auth_authorize(configuration: &configuration::Configuration, response_type: &str, client_id: &str, redirect_uri: Option<&str>, scope: Option<Vec<String>>, state: Option<&str>, prompt: Option<Vec<String>>, code_challenge: Option<&str>, code_challenge_method: Option<&str>, response_mode: Option<&str>, nonce: Option<&str>) -> Result<(), Error<RequestOAuthAuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_response_type = response_type;
    let p_query_client_id = client_id;
    let p_query_redirect_uri = redirect_uri;
    let p_query_scope = scope;
    let p_query_state = state;
    let p_query_prompt = prompt;
    let p_query_code_challenge = code_challenge;
    let p_query_code_challenge_method = code_challenge_method;
    let p_query_response_mode = response_mode;
    let p_query_nonce = nonce;

    let uri_str = format!("{}/oauth/authorize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("response_type", &p_query_response_type.to_string())]);
    req_builder = req_builder.query(&[("client_id", &p_query_client_id.to_string())]);
    if let Some(ref param_value) = p_query_redirect_uri {
        req_builder = req_builder.query(&[("redirect_uri", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scope {
        req_builder = match "ssv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("scope".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("scope", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prompt {
        req_builder = match "ssv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("prompt".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("prompt", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_code_challenge {
        req_builder = req_builder.query(&[("code_challenge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_code_challenge_method {
        req_builder = req_builder.query(&[("code_challenge_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_response_mode {
        req_builder = req_builder.query(&[("response_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestOAuthAuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request OAuth2 authorization. If successful, receive authorization grant via redirect.
pub async fn request_o_auth_authorize_post(configuration: &configuration::Configuration, response_type: &str, client_id: &str, redirect_uri: Option<&str>, scope: Option<&str>, state: Option<&str>, prompt: Option<&str>, code_challenge: Option<&str>, code_challenge_method: Option<&str>, response_mode: Option<&str>, nonce: Option<&str>) -> Result<(), Error<RequestOAuthAuthorizePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_response_type = response_type;
    let p_form_client_id = client_id;
    let p_form_redirect_uri = redirect_uri;
    let p_form_scope = scope;
    let p_form_state = state;
    let p_form_prompt = prompt;
    let p_form_code_challenge = code_challenge;
    let p_form_code_challenge_method = code_challenge_method;
    let p_form_response_mode = response_mode;
    let p_form_nonce = nonce;

    let uri_str = format!("{}/oauth/authorize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("response_type", p_form_response_type.to_string());
    multipart_form_params.insert("client_id", p_form_client_id.to_string());
    if let Some(param_value) = p_form_redirect_uri {
        multipart_form_params.insert("redirect_uri", param_value.to_string());
    }
    if let Some(param_value) = p_form_scope {
        multipart_form_params.insert("scope", param_value.to_string());
    }
    if let Some(param_value) = p_form_state {
        multipart_form_params.insert("state", param_value.to_string());
    }
    if let Some(param_value) = p_form_prompt {
        multipart_form_params.insert("prompt", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_challenge {
        multipart_form_params.insert("code_challenge", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_challenge_method {
        multipart_form_params.insert("code_challenge_method", param_value.to_string());
    }
    if let Some(param_value) = p_form_response_mode {
        multipart_form_params.insert("response_mode", param_value.to_string());
    }
    if let Some(param_value) = p_form_nonce {
        multipart_form_params.insert("nonce", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestOAuthAuthorizePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke OAuth2 token by token.  #### Authentication  - **Confidential clients**: Must authenticate using HTTP Basic Authentication with Client ID as username and Client Secret as password in the Authorization header.
pub async fn revoke_o_auth_token(configuration: &configuration::Configuration, token: Option<&str>, token_type_hint: Option<&str>) -> Result<(), Error<RevokeOAuthTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_token = token;
    let p_form_token_type_hint = token_type_hint;

    let uri_str = format!("{}/oauth/token/revoke", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_token {
        multipart_form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = p_form_token_type_hint {
        multipart_form_params.insert("token_type_hint", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeOAuthTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

